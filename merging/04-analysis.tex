

\chapter{Аналитический раздел}

С ростом числа запросов к системе, встает вопрос о ее масштабировании. Масштабирование --- это процесс роста системы со временем, для эффективной обработки все большего и большего количества запросов в единицу времени~\cite{scaling}. Выделяют два вида масштабирования: горизонтальное и вертикальное~\mbox{\cite{comp, part_algos, com_analysis}}. Вертикальное масштабирование происходит за счет увеличения мощности вычислительного узла. Однако, использования только такого подхода часто не хватает, поскольку постоянно увеличивая мощность, однажды будет достигнут <<потолок>> производительности и дальнейшие аппаратные улучшения будут недоступны. В таком случае для дальнейшего роста производительности применяют горизонтальное масштабирование, которое заключается в добавлении новых вычислительных узлов, выполняющих одинаковые функции. Для расширения возможностей горизонтального масштабирования используются балансировщики нагрузки~\cite{part_algos, comp}.

Балансировщик нагрузки --- это программа, принимающая весь
входящий трафик запросов и распределяющая его между несколькими
вычислительными системами с целью оптимизации использования
ресурсов, сокращения времени обслуживания запросов, а также
обеспечения отказоустойчивости \cite{comp}.


\section{Постановка задачи}

В вычислительных сетях, использование распределения нагрузки для оптимизации использования ресурсов, называют балансировкой нагрузки \cite{gaud}.

Постановка задачи балансировки нагрузки выглядит следующим образом: имеется множество, состоящее из $n$ запросов, которое должно быть обслужено $M$ узлами. 
Каждый узел может обслуживать не более одного запроса в каждый момент времени. Каждый запрос обслуживается не более, чем одним узлом в каждый момент времени, а процесс обслуживания запроса не может быть прерван. 

Под расписанием понимается функция, которая каждому узлу $l$ и моменту времени $t$ сопоставляет запрос, обслуживаемый узлом $l$ в момент времени $t$, либо указывает, что узел $l$ в момент $t$ простаивает. Каждому запросу $i$ сопоставлена неубывающая функция штрафа $\phi_i(t)$. Тогда решением задачи балансировки нагрузки является составление расписания $s$, которое минимизирует выражение~\eqref{eq:main_task}~\cite{gaud}.

\begin{equation}
	\label{eq:main_task}	
	F_{max} =   \max_{i \in n} \{\phi_i(t_i(s))\}, 
\end{equation}

где $t_i(s)$ --- момент завершения обслуживания запроса $i$ при расписании~$s$.

\section{Алгоритмы решения задачи балансировки}

Балансировщик нагрузки работает по одному из алгоритмов, решающих задачу балансировки. На вход этому алгоритму подается некоторое число запросов, приходящих в систему и набор вычислительных узлов, которыми располагает система. Задача алгоритма сводится к минимизации времени обработки запросов, за счет распределения запросов по вычислительным узлам.

Для анализа алгоритмов балансировки могут быть выделены следующие параметры~\cite{com_analysis}:
\begin{itemize}
	\item точность прогнозирования --- степень соответствия расчетных результатов работы алгоритма их фактическому значению;  
	\item отказоустойчивость --- показывает устойчивость
	алгоритма к возникновению разнообразных ошибок;
	\item время обработки нового запроса --- время от поступления нового запроса до его перенаправления к цели.
\end{itemize}

Методы балансировки условно разделяют на статические и динамические~\cite{drr, com_analysis, rate_comp}. 

При динамической балансировке нагрузки, распределение запросов происходит на основе собранной информации об узлах. 

В статических алгоритмах, запрос распределяется в узел при появлении в балансировщике, а состояние узлов не оказывает влияния на это распределение~\cite{rate_comp, com_analysis}.


\section{Статическая балансировка}

Статическая балансировка --- это метод распределения нагрузки на узлы, основанный на заранее определенных параметрах.

К самым распространенным статическим алгоритмам относят: Round Robin и его модификацию Weighted Round Robin \cite{drr, comp, part_algos, com_analysis}.

\subsection{Round Robin}

Round Robin --- это алгоритм балансировки нагрузки, который направляет каждый следующий запрос на новый вычислительный узел по заранее определенному порядку \cite{comp}.

Пусть имеется $N$ запросов и $M$ узлов. Алгоритм состоит из следующих шагов.

\begin{enumerate}
	\item Сформировать массив, содержащий узлы.
	\item Создать переменную $i = 0$.
	\item Для каждого запроса из $N$:
	\begin{itemize}
		\item отправить текущий запрос на $i$-й узел в массиве;
		\item увеличить значение $i$;
		\item если $i >= M$, то $i = 0$.
	\end{itemize}	
\end{enumerate}

Особенности алгоритма Round Robin:
\begin{itemize}
	\item высокая степень точности прогнозирования;
	\item невозможно отследить вышел ли из строя узел, в результате, возможно, что на неработающий узел будут посылаться запросы, т.~е. низкая отказоустойчивость;
	\item никакие затратные по времени операции не производятся и попавший в балансировщик запрос практически сразу направляется в узел;
	\item различия в технических характеристиках узлов не учитываются, что может привести к неравномерному распределению нагрузки.
\end{itemize}


\textbf{Weighted Round Robin}


Алгоритм Weighted Round Robin представляет собой модификацию алгоритма Round Robin, в которой каждому узлу вручную назначается некоторый параметр, называемый весом, с помощью которого можно варьировать количество запросов, отправляемых на конкретный узел~\cite{part_algos}. Если помимо множества запросов и узлов, задан массив весов $weights$, длины $M$. Тогда алгоритм состоит из следующих шагов.
\begin{enumerate}
	\item Сформировать массив $nodes$ содержащий узлы, при этом повторить каждый $j$-й узел $weights[j]$ раз.
	\item Сохранить длину массива $nodes$ в переменную $L$.
	\item Создать переменную $i = 0$.
	\item Для каждого запроса из $N$:
	\begin{itemize}
		\item распределить текущий запрос на $i$-й узел в массиве;
		\item увеличить значение $i$;
		\item если $i >= L$, то $i = 0$.
	\end{itemize}	
\end{enumerate}


Особенности алгоритма Weighted Round Robin:
\begin{itemize}
	\item высокая степень точности прогнозирования;
	\item низкая отказоустойчивость, поскольку невозможно отследить вышел ли из строя некоторый узел, при этом, если вышел из строя узел с самым высоким весом, то на него все еще будет посылаться большее число запросов;
	\item благодаря весам, возможно осуществить настройку алгоритма таким образом, чтобы он учитывал различия в технических характеристиках узлов.
\end{itemize}



\section{Динамическая балансировка}

Особенностью динамических алгоритмов балансировки является необходимость в постоянном обмене актуальной информацией о узлах.
Простой способ периодического децентрализованного обмена информацией о состоянии заключается в том, что каждый узел периодически отправляет свое текущее состояние всем другим узлам \cite{drr}.

К динамическим алгоритмам относятся следующие~\cite{drr, dll_warsh, mainsource}:
\begin{itemize}
	\item Dynamic Round Robin;
	\item Least Connections;
	\item Weighted Least Connections;
	\item Least Response Time;
	\item Хеширование на основе IP-адреса;
	\item Хеширование на основе URL-адреса;
	\item Метод фиксированных весов.
\end{itemize}


\subsection{Dynamic Round Robin}

Алгоритм Dynamic Round Robin динамически изменяет расписание, т.~е. распределение запросов по узлам, в зависимости от текущих характеристик узлов \cite{drr}. Dynamic Round Robin может исключать недоступные узлы, перенаправляя задачи на доступные узлы, что позволяет избежать проблем при работе с неисправными узлами. 
В алгоритме Dynamic Round Robin на расписание могут влиять следующие характеристики \cite{dll_warsh, com_analysis, part_algos}: 
\begin{itemize}
	\item количество соединений;
	\item среднее значение загрузки системы за период в 1 минуту, строится на основе процессов, т.~е. программ в стадии выполнения, стоящих в очереди ожидания ресурсов, выражается как отношение количества ожидающих процессов к общему количеству ядер;
	\item загрузка процессора узла в текущий момент времени, выраженная в процентах;
	\item использование памяти узла, выраженное в процентах относительно общего количества;
	\item географическое расстояние между узлами.
\end{itemize}
Алгоритм Dynamic Round Robin, выбирающий узлы по их текущей нагрузке, состоит из следующих шагов для каждого входящего запроса  \cite{com_analysis}.
\begin{enumerate}
	\item Установить переменную \textit{target} на первый доступный узел.
	\item Цикл по всем доступным узлам, кроме первого:
	 \begin{itemize}
	 	\item если нагрузка на текущий рассматриваемый узел меньше нагрузки узла \textit{target}, то установить \textit{target} на текущий узел.
	 \end{itemize}
	\item Отправить запрос на узел \textit{target}.
\end{enumerate}

Особенности алгоритма Dynamic Round Robin:
\begin{itemize}
	\item низкая точность прогнозирования, поскольку распределение запросов сильно зависит от внешних факторов;
	\item высокая отказоустойчивость, поскольку в алгоритме учитывается ситуация отказа узлов.
\end{itemize}


\subsection{Least Connections}

Алгоритм Least Connections распределяет нагрузку между узлами, в зависимости от количества активных соединений, обслуживаемых каждым узлом.
Узел с наименьшим числом соединений будет обрабатывать следующий запрос, а узлы с большим числом соединений будут перераспределять свою нагрузку на узлы с меньшей загрузкой~\cite{leastconnection}.

Если имеется $N$ запросов, $M$ узлов и для каждого узла есть количество активных соединений $conns$. 
Тогда алгоритм состоит из следующих шагов:
\begin{enumerate}
	\item сформировать массив, содержащий узлы;
	\item установить указатель $target$ на первый узел;
	\item пройтись циклом по всем узлам массива, кроме первого:
	\begin{itemize}
		\item если $conns$ текущего узла меньше $conns$ узла $target$, то установить $target$ на текущий узел; 
	\end{itemize}
	\item отправить запрос на узел $target$.
\end{enumerate}

Особенности алгоритма Least Connections:
\begin{itemize}
	\item низкая степень прогнозирования; 
	\item низкая стабильность;
	\item высокая отказоустойчивость, поскольку постоянно собирается информация об узлах, и, в случае отказа, система перераспределит ресурсы;
	\item высокая потребность в ресурсах, поскольку необходимо постоянно собирать информацию о узлах в реальном времени;
	\item высокое время обработки нового запроса, поскольку балансировщику нагрузки необходимо время, чтобы правильно перенаправить задачу.
\end{itemize}

\textbf{Weighted Least Connections}

Данный алгоритм комбинирует принципы алгоритмов Least Connections и Weighted Round Robin~\cite{part_algos}.
Он учитывает как веса узлов, так и количество активных соединений. 
Новое сетевое подключение предоставляется узлу, который имеет минимальное отношение количества текущих активных подключений к его весу \cite{mainsource}.

Если имеется $N$ запросов, $M$ узлов и для каждого узла есть количество соединений $conns$ и вес $weight$.
Тогда алгоритм состоит из следующих шагов:
\begin{enumerate}
	\item сформировать массив, содержащий узлы;
	\item установить указатель $target$ на первый узел;
	\item пройтись циклом по всем узлам массива, кроме первого:
	\begin{itemize}
	\item если отношение $conns$ и $weight$ текущего узла меньше отношения $conns$ и $weight$ узла $target$, то установить $target$ на текущий узел; 
	\end{itemize}
	\item отправить запрос на узел $target$.
\end{enumerate}

Особенности алгоритма Weighted Least Connections:
\begin{itemize}
	\item низкая степень прогнозирования; 
	\item низкая стабильность;
	\item высокая отказоустойчивость;
	\item высокая потребность в ресурсах;
	\item высокое время обработки нового запроса;
	\item благодаря весам, возможно осуществить настройку алгоритма таким образом, чтобы он учитывал различия в технических характеристиках узлов.
\end{itemize}


\subsection{Least Response Time}

Данный алгоритм имеет схожесть с алгоритмом Least Connections, только при распределении нагрузки он руководствуется наименьшим временем ответа узла.
При выборе учитывается производительность узлов и балансировщик стремится направить запрос к наиболее подходящему узлу~\cite{aws}.

Если имеется $N$ запросов, $M$ узлов и для каждого узла есть время ответа на предыдущий запрос $time$.
Тогда алгоритм состоит из следующих шагов:

\begin{enumerate}
	\item сформировать массив, содержащий узлы;
	\item установить указатель $target$ на первый узел;
	\item пройтись циклом по всем узлам массива, кроме первого:
	\begin{itemize}
		\item если $time$ текущего узла меньше $time$ узла $target$, то установить $target$ на текущий узел; 
	\end{itemize}
	\item отправить запрос на узел $target$.
\end{enumerate}

Особенности алгоритма Least Response Time:
\begin{itemize}
	\item низкая степень прогнозирования; 
	\item низкая стабильность;
	\item высокая отказоустойчивость;
	\item высокая потребность в ресурсах;
	\item высокое время обработки нового запроса;
	\item если время ответа каждого узла одинаково, то алгоритм следует выбору по правилам алгоритма Round Robin.
\end{itemize}

\subsubsection{Методы на основе хеширования}

Методы балансировки нагрузки на основе хеширования работают по общему принципу:
\begin{enumerate}
	\item Из пришедшего запроса выбрать информацию (например, IP-адрес или URL-адрес), которая считается ключом хеш-функции в рамках данного алгоритма.
	\item На основе ключа вычислить значение хеш-функции, которое соответствует идентификатору узла, на который следует перенаправить запрос для его обработки.
	\item Перенаправить запрос на узел, чей идентификатор был вычислен ранее.
\end{enumerate}

\subsubsection*{Хеширование на основе IP-адреса}

Алгоритм балансировки нагрузки <<Хеширование на основе IP-адреса>> работает по общему принципу методов балансировки нагрузки на основе хеширования.
Ключом хеш-функции в данном алгоритме считается IP-адрес источника запроса \cite{nginx, aws, kemp}.
Запросы, имеющие один и тот же IP-адрес, будут обслужены одним и тем же узлом.
То есть, если имеются запросы $r_1$, $r_2$, узлы $l_1$, $l_2$, моменты времени $t_1$, $t_2$ и функция расписания $s$, то, в соответствии с данным алгоритмом, будет выполнено следующее:
\begin{equation}
	(\forall t_1, t_2) \left(\begin{cases}
		s(l_1, t_1) = r_1, \\
		s(l_2, t_2) = r_2, \\
		r_1.ip\_address = r_2.ip\_address.
	\end{cases} \Rightarrow l_1 = l_2 \right)
\end{equation}

Особенности алгоритма <<Хеширование на основе IP-адреса>>:
\begin{itemize}
	\item алгоритм гарантирует, что все запросы от одного и того же пользователя направляются на тот же сервер;
	\item алгоритм предсказуем;
	\item добавление новых серверов потребует лишь изменения хеш-функции для корректной работы алгоритма;
	\item неравномерная нагрузка на узел, если запросы начинают приходить из сети, использующей NAT, с большим количеством пользователей.
\end{itemize}

\subsubsection*{Хеширование на основе URL-адреса}

Алгоритм балансировки нагрузки <<Хеширование на основе URL-адреса>> работает по общему принципу методов балансировки нагрузки на основе хеширования.
Ключом хеш-функции в данном алгоритме считается URL-адрес, к которому обращается источник запроса \cite{nginx, kemp, haproxy}.
Запросы к одному и тому же URL-адресу, будут обслужены одним и тем же узлом.
То есть, если имеются запросы $r_1$, $r_2$, узлы $l_1$, $l_2$, моменты времени $t_1$, $t_2$ и функция расписания $s$, то, в соответствии с данным алгоритмом, будет выполнено следующее:
\begin{equation}
	(\forall t_1, t_2) \left(\begin{cases}
		s(l_1, t_1) = r_1, \\
		s(l_2, t_2) = r_2, \\
		r_1.url\_address = r_2.url\_address.
	\end{cases} \Rightarrow l_1 = l_2 \right)
\end{equation}

Особенности алгоритма <<Хеширование на основе URL-адреса>>:
\begin{itemize}
	\item алгоритм гарантирует, что все запросы к одному и тому же URL направляются на тот же сервер;
	\item алгоритм предсказуем;
	\item изменение структуры URL может потребовать перенастройки балансировщика;
	\item популярные URL могут создавать неравномерную нагрузку на узлы.
\end{itemize}

\subsubsection{Метод фиксированных весов}

В методе фиксированных весов, администратор назначает каждому узлу вес, после чего все запросы будут приходить на узел с максимальным весом \cite{kemp}.
Если узел перестаёт справляться с нагрузкой, запросы начинают перенаправляться на узел, с весом меньше.

Шаги инициализации алгоритма:
\begin{enumerate}
	\item N = количество узлов
	\item nodes = массив узлов
	\item weights = массив весов таких, что weights[i] --- вес узла i, назначенный администратором
	\item i = 1
	\item Пока i <= N:
	\begin{itemize}
		\item nodes[i].weight = weights[i]
		\item i = i + 1
	\end{itemize}
\end{enumerate}

Шаги работы алгоритма:
\begin{enumerate}
	\item w = max(weights)
	\item request\_sent\_flag = 0
	\item Пока request\_sent\_flag = 0 и w > 0:
	\begin{itemize}
		\item node = узел с весом w
		\item Если узел node работоспособен, перенаправить запрос узлу node, request\_sent\_flag = 1
		\item Иначе, w = w - 1
	\end{itemize}
\end{enumerate}

Таким образом, если имеется запрос $r$, узел $l$, момент времени $t$, функция расписания $s$, и выполняется равенство $s(l, t) = r$ то, $l$ --- узел с наибольшим весом, доступный в момент времени $t$.

Особенности метода фиксированных весов:
\begin{itemize}
	\item алгоритм гарантирует, что все запросы будут направляться на доступный в текущий момент времени узел с максимальным весом;
	\item алгоритм предсказуем;
	\item веса узлов назначаются вручную;
	\item вес узла не меняется в процессе работы.
\end{itemize}