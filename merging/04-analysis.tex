

\chapter{Аналитический раздел}

С ростом числа запросов к системе, встает вопрос о ее масштабировании. 
Масштабирование --- это процесс роста системы со временем, для эффективной обработки все большего и большего количества запросов в единицу времени~\cite{scaling}. 
Выделяют два вида масштабирования: горизонтальное и вертикальное~\mbox{\cite{comp, part_algos, com_analysis}}.
Вертикальное масштабирование происходит за счет увеличения мощности вычислительного узла.  
Горизонтальное масштабирование, заключается в добавлении новых вычислительных узлов, выполняющих одинаковые функции.
% Для расширения возможностей горизонтального масштабирования используются балансировщики нагрузки~\cite{part_algos, comp}.
Для эффективного функционирования системы в случае её горизониального масштабирования, используются балансировщики нагрузки~\cite{part_algos, comp}.

Балансировщик нагрузки --- это программа, принимающая весь
входящий трафик запросов и распределяющая его между несколькими
вычислительными узлами с целью оптимизации использования
ресурсов, сокращения времени обслуживания запросов, а также
обеспечения отказоустойчивости~\cite{comp}.


\section{Постановка задачи}

Постановка задачи балансировки нагрузки формулируется следующим образом:
% имеется множество, состоящее из $n$ запросов, которое должно быть обслужено $M$ узлами. 
имеется $N$ запросов, которые должны быть обслужены $M$ узлами.
Каждый узел может обслуживать не более одного запроса в каждый момент времени.
Каждый запрос обслуживается не более, чем одним узлом в каждый момент времени, а процесс обслуживания запроса не может быть прерван. 

Под расписанием понимается функция, которая каждому узлу $l$ и моменту времени $t$ сопоставляет запрос, обслуживаемый узлом $l$ в момент времени $t$, либо указывает, что узел $l$ в момент $t$ простаивает.
Каждому запросу $i$ сопоставлена неубывающая функция штрафа $\phi_i(t)$. В качестве такой функции может быть выбрана функция $\phi_i(t) = t$.
Тогда решением задачи балансировки нагрузки является составление расписания $s$, которое минимизирует выражение~\eqref{eq:main_task}~\cite{gaud}.

\begin{equation}
	\label{eq:main_task}	
	F_{max} =   \max_{i \in n} \{\phi_i(t_i(s))\}, 
\end{equation}

где $t_i(s)$ --- момент завершения обслуживания запроса $i$ при расписании~$s$.

\section{Алгоритмы решения задачи балансировки}

Балансировщик нагрузки работает по одному из алгоритмов, решающих задачу балансировки нагрузки приближенно.
На вход этому алгоритму подаются набор запросов, приходящих в систему и набор вычислительных узлов, которыми система располагает.
Задача алгоритма сводится к уменьшению времени обработки запросов за счет распределения запросов по вычислительным узлам.

Для анализа алгоритмов балансировки выделяют следующие критерии~\cite{com_analysis}:
\begin{itemize}
	\item точность прогнозирования --- степень соответствия расчетных результатов работы алгоритма их фактическому значению;  
	\item отказоустойчивость --- показатель устойчивости алгоритма к возникновению разнообразных ошибок;
	\item время обработки нового запроса --- время от поступления нового запроса до его перенаправления к цели.
\end{itemize}

Методы балансировки условно разделяют на статические и динамические~\cite{drr, com_analysis, rate_comp}. 

\section{Статическая балансировка}

Статическая балансировка --- это метод распределения нагрузки на узлы, основанный на заранее определенных параметрах~\cite{com_analysis, intuit}.

К статическим алгоритмам балансировки относят алгоритмы на основе хеширования и алгоритмы циклического перебора (англ. Round Robin)~\mbox{\cite{nginx, aws, haproxy, part_algos, com_analysis}}.

\subsection{Алгоритмы на основе хеширования}

Алгоритмы балансировки нагрузки на основе хеширования работают по общему принципу, который состоит из следующих шагов:
\begin{enumerate}
	\item из пришедшего запроса выбрать информацию (например, IP-адрес или URL-адрес), которая считается ключом хеш-функции в рамках данного алгоритма;
	\item на основе ключа вычислить значение хеш-функции, которое соответствует идентификатору узла, на который следует перенаправить запрос для его обработки;
	\item перенаправить запрос на узел, чей идентификатор был вычислен ранее.
\end{enumerate}

\subsection*{Хеширование на основе IP-адреса}

Алгоритм балансировки нагрузки <<Хеширование на основе IP-адреса>> работает по общему принципу методов балансировки нагрузки на основе хеширования.
Ключом хеш-функции в данном алгоритме считается IP-адрес источника запроса~\cite{nginx, aws, kemp}.
Запросы, имеющие один и тот же IP-адрес, будут обслужены одним и тем же узлом.
Если имеются запросы $r_1$, $r_2$, узлы $l_1$, $l_2$, моменты времени $t_1$, $t_2$ и функция расписания $s$, то, в соответствии с данным алгоритмом, будет выполнено следующее:
\begin{equation}
	(\forall t_1, t_2) \left(\begin{cases}
		s(l_1, t_1) = r_1, \\
		s(l_2, t_2) = r_2, \\
		r_1.ip\_address = r_2.ip\_address.
	\end{cases} \Rightarrow l_1 = l_2 \right).
\end{equation}

Особенности алгоритма <<Хеширование на основе IP-адреса>>:
\begin{itemize}
	\item алгоритм гарантирует, что все запросы от одного и того же пользователя направляются на один и тот же сервер;
	\item алгоритм прогнозируемый; 
	\item добавление новых серверов потребует лишь изменения хеш-функции для корректной работы алгоритма;
	\item неравномерная нагрузка на узел, если запросы начинают приходить из сети, использующей NAT, с большим количеством пользователей.
\end{itemize}

\subsection*{Хеширование на основе URL-адреса}

Алгоритм балансировки нагрузки <<Хеширование на основе URL-адреса>> работает по общему принципу методов балансировки нагрузки на основе хеширования.
Ключом хеш-функции в данном алгоритме считается URL-адрес, к которому обращается источник запроса~\cite{nginx, kemp, haproxy}.
Запросы к одному и тому же URL-адресу, будут обслужены одним и тем же узлом.
То есть, если имеются запросы $r_1$, $r_2$, узлы $l_1$, $l_2$, моменты времени $t_1$, $t_2$ и функция расписания $s$, то, в соответствии с данным алгоритмом, будет выполнено следующее:
\begin{equation}
	(\forall t_1, t_2) \left(\begin{cases}
		s(l_1, t_1) = r_1, \\
		s(l_2, t_2) = r_2, \\
		r_1.url\_address = r_2.url\_address.
	\end{cases} \Rightarrow l_1 = l_2 \right)
\end{equation}

Особенности алгоритма <<Хеширование на основе URL-адреса>>:
\begin{itemize}
	\item алгоритм гарантирует, что все запросы к одному и тому же URL направляются на тот же сервер;
	\item алгоритм прогнозируемый;
	\item изменение структуры URL может потребовать перенастройки балансировщика;
	\item популярные URL могут создавать неравномерную нагрузку на узлы.
\end{itemize}

\subsection{Алгоритмы циклического перебора}

В алгоритмах циклического перебора каждый следующий запрос отправляется на новый вычислительный узел по заранее определенному порядку~\cite{comp}.

Алгоритмы циклического перебора работают по общему принципу.
Если имеется $N$ запросов и $nodes$ --- массив, содержащий узлы, а $M$ длина этого массива, то алгоритм состоит из следующих шагов:
\begin{enumerate}
	\item создать переменную $i = 0$;
	\item для каждого запроса из $N$:
	\begin{itemize}
		\item отправить текущий запрос на $i$-й узел в массиве;
		\item увеличить значение $i$;
		\item если $i >= M$, то $i = 0$.
	\end{itemize}	
\end{enumerate}

Особенности алгоритма равномерного распределения:
\begin{itemize}
	\item алгоритм прогнозируемый;
	\item невозможно отследить вышел ли из строя узел, в результате, возможно, что на неработающий узел будут посылаться запросы, т.~е. алгоритм не обладает отказоустойчивостью;
	\item никакие затратные по времени операции не производятся в балансировщике;
	\item различия в технических характеристиках узлов не учитываются, что может привести к неравномерному распределению нагрузки.
\end{itemize}


\subsection*{Алгоритм взвешенного циклического перебора}

Алгоритм взвешенного циклического перебора (англ. Weighted Round Robin) представляет собой модификацию алгоритма равномерного распределения, в которой каждому узлу вручную назначается некоторый параметр, называемый весом, с помощью которого можно варьировать количество запросов, отправляемых на конкретный узел~\cite{part_algos}.

Алгоритм взвешенного циклического перебора работает по общему принципу, за исключением того, что в массиве $nodes$ каждый $i$-й узел повторяется $w_i$ раз, где $w_i$ --- вес, назначенный этому узлу.

Особенности алгоритма взвешенного циклического перебора:
\begin{itemize}
	\item алгоритм прогнозируемый;
	\item алгоритм не отказоустойчивый, поскольку невозможно отследить вышел ли из строя некоторый узел, при этом, если вышел из строя узел с самым высоким весом, то на него все еще будет посылаться большее число запросов;
	\item благодаря весам, возможно осуществить настройку алгоритма таким образом, чтобы он учитывал различия в технических характеристиках узлов.
\end{itemize}


\section{Динамическая балансировка}

Динамическая балансировка --- это метод распределения нагрузки на узлы, который предусматривает перераспределение вычислительной нагрузки во время работы, т.~е. динамическое обновление расписания~\cite{intuit}.
 

Особенностью динамических алгоритмов балансировки является необходимость в постоянном обмене актуальной информацией об узлах.
Простой способ периодического децентрализованного обмена информацией о состоянии заключается в том, что каждый узел периодически отправляет свое текущее состояние всем другим узлам \cite{drr}.

К динамическим алгоритмам относят~\cite{drr, dll_warsh, mainsource}
\begin{itemize}
	\item алгоритм динамического циклического перебора (англ. Dynamic Round Robin);
	\item алгоритмы наименьших соединений (англ. Least Connections);
	\item алгоритм наименьшего времени ответа (англ. Least Response Time);
    \item алгоритм фиксированных весов (англ. Fixed Weighting);
	\item алгоритм 2 (N) случайных выборов (англ. Random 2 (N) choices);
	\item алгоритм на основе ресурсов (англ. Resource based).
\end{itemize}


\subsection{Алгоритм динамического циклического перебора}

Алгоритм динамического циклического перебора работает по принципу взвешенного циклического перебора, за исключением того, что 
в динамическом алгоритме циклического перебора происходит обновление весов на основании текущих характеристик узлов~\cite{drr, nginx}.

Алгоритм может исключать недоступные узлы, перенаправляя задачи на доступные узлы, что позволяет избежать проблем при работе с неисправными узлами. 
В алгоритме динамического циклического перебора на расписание могут влиять следующие характеристики~\cite{dll_warsh, com_analysis, part_algos}: 
\begin{itemize}
	\item количество соединений;
	\item среднее значение загрузки системы за некоторый период времени;
	\item загрузка процессора узла в текущий момент времени;
	\item использование памяти узла в текущий момент времени.
\end{itemize}

Особенности алгоритма динамического циклического перебора:
\begin{itemize}
	\item алгоритм непрогнозируемый;
	\item необходимо постоянно собирать информацию об узлах в реальном времени;
	\item алгоритм отказоустойчивый.
\end{itemize}


\subsection{Алгоритмы наименьших соединений}

Алгоритм наименьших соединений распределяет нагрузку между узлами, в зависимости от количества активных соединений, обслуживаемых каждым узлом.
Узел с наименьшим числом соединений будет обрабатывать следующий запрос, а узлы с большим числом соединений будут перераспределять свою нагрузку на узлы с меньшей загрузкой~\cite{leastconnection}.

Алгоритмы наименьших соединений работают по общему принципу.
Если имеется $N$ запросов, $M$ узлов и характеристики узлов хранятся в массиве $parameters$, то алгоритм состоит из следующих шагов:
\begin{enumerate}
	\item сформировать массив, содержащий узлы;
	\item установить указатель $target$ на первый узел;
	\item пройтись циклом по всем узлам массива, кроме первого:
	\begin{itemize}
		\item если значение элемента $parameters$, соответствующее текущему узлу, меньше значения элемента $parameters$, соответствующего узлу $target$, то установить $target$ на текущий узел; 
	\end{itemize}
	\item отправить запрос на узел $target$.
\end{enumerate}

В классической реализации алгоритма наименьших соединений, массив $parameters$ содержит количество активных соединений для каждого узла.

Особенности алгоритма наименьших соединений:
\begin{itemize}
    \item для каждого запроса выполняется цикл по всем узлам системы;
	\item алгоритм непрогнозируемый; 
	\item алгоритм отказоустойчивый, поскольку постоянно собирается информация об узлах, и, в случае отказа, система перераспределит ресурсы;
	\item необходимо постоянно собирать информацию об узлах в реальном времени;
	\item балансировщику нагрузки необходимо время, чтобы правильно перенаправить задачу.
\end{itemize}

\subsection*{Алгоритм взвешенных наименьших соединений}

Данный алгоритм комбинирует принципы алгоритма наименьших соединений и алгоритма взвешенного циклического перебора~\cite{part_algos}.
Он учитывает как веса узлов, так и количество активных соединений. 
Алгоритм работает по общему принципу алгоритмов наименьших соединений. Для $i$-го узла значение массива $parameters[i]$ равно отношению количества активных подключений к заданному весу~\cite{mainsource}.

Особенности алгоритма взвешенных наименьших соединений:
\begin{itemize}
    \item для каждого запроса выполняется цикл по всем узлам системы;
	\item алгоритм непрогнозируемый; 
	\item алгоритм отказоустойчивый;
	\item необходимо постоянно собирать информацию об узлах в реальном времени;
	\item благодаря весам, возможно осуществить настройку алгоритма таким образом, чтобы он учитывал различия в технических характеристиках узлов.
\end{itemize}


\subsection{Алгоритм наименьшего времени ответа}

% Данный алгоритм имеет схожесть с алгоритмом наименьших соединений, только при распределении нагрузки он руководствуется наименьшим временем ответа узла.
Данный алгоритм совпадает с алгоритмом наименьших соединений, с точностью до критерия выбора узла: если в алгоритме наименьших соединений запрос перенаправлялся на узел с наименьшим количеством соединений, то в данном алгоритме запрос перенаправляется на узел с наименьшим временем ответа.
При выборе учитывается производительность узлов и балансировщик стремится направить запрос к наиболее подходящему узлу~\cite{aws}.

Если имеется $N$ запросов, $M$ узлов и для каждого узла есть время ответа на предыдущий запрос $time$, то алгоритм состоит из следующих шагов:

\begin{enumerate}
	\item сформировать массив, содержащий узлы;
	\item установить указатель $target$ на первый узел;
	\item пройтись циклом по всем узлам массива, кроме первого:
	\begin{itemize}
		\item если $time$ текущего узла меньше $time$ узла $target$, то установить $target$ на текущий узел; 
	\end{itemize}
	\item отправить запрос на узел $target$.
\end{enumerate}

Особенности алгоритма наименьшего времени ответа:
\begin{itemize}
    \item для каждого запроса выполняется цикл по всем узлам системы;
	\item алгоритм непрогнозируемый; 
	\item алгоритм отказоустойчивый;
	\item необходимо постоянно собирать информацию об узлах в реальном времени;
	\item если время ответа каждого узла одинаково, то алгоритм следует выбору по правилам алгоритма циклического перебора.
\end{itemize}

\subsection{Алгоритм фиксированных весов}

% В алгоритме фиксированных весов, администратор назначает каждому узлу вес, после чего все запросы будут приходить на узел с максимальным весом~\cite{kemp}.
В алгоритме фиксированных весов каждому узлу назначается вес, после чего все запросы начинают приходить на узел с максимальным весом~\cite{kemp}.
Если узел перестает справляться с нагрузкой, запросы начинают перенаправляться на узел с весом меньше.

% Если имеется $M$ узлов, записанных в массив $nodes$ и $weights$ --- массив весов, назначенных администратором, то алгоритм для каждого приходящего запроса состоит из следующих шагов:
Если имеется $M$ узлов, записанных в массив $nodes$, и $weights$ --- массив их весов соответственно, то алгоритм для каждого приходящего запроса состоит из следующих шагов:
\begin{enumerate}
	\item записать в $w$ максимальное значение $weights$;
	\item $request\_sent\_flag = 0$;
	\item пока $request\_sent\_flag = 0$ и $w > 0$:
	\begin{itemize}
		\item записать в $node$ узел, вес которого равен $w$;
		\item если узел $node$ может принять запрос то, перенаправить запрос узлу $node$, установить значение $request\_sent\_flag = 1$;
		\item иначе, $w = w - 1$.
	\end{itemize}
\end{enumerate}

Таким образом, если имеется запрос $r$, узел $l$, момент времени $t$, функция расписания $s$, и выполняется равенство $s(l, t) = r$ то, $l$ --- узел с наибольшим весом, доступный в момент времени $t$.

Особенности алгоритма фиксированных весов:
\begin{itemize}
	\item алгоритм гарантирует, что все запросы будут направляться на доступный в текущий момент времени узел с максимальным весом;
	\item алгоритм непрогнозируемый;
	\item алгоритм отказоустойчивый;
	\item веса узлов назначаются вручную;
	\item вес узла не меняется в процессе работы.
\end{itemize}

\subsection{Алгоритм 2 (N) случайных выборов}

Алгоритм 2 (N) случайных выборов --- алгоритм, при котором определяется нагрузка $N \ge 2$ серверов, выбранных случайным образом, и запрос отправляется на наименее загруженный из них. 
В случае $N=2$ максимальная нагрузка на $n$ серверов с большой вероятностью составит $\Theta(\log  \log n)$~\cite{pwr2choices}.

Данный метод может быть использован, когда запрос требуется отправить на наименее загруженный сервер, однако, полная информация о загрузке всех серверов может оказаться дорогостоящей для получения~\cite{pwr2choices}.

Альтернативный подход при котором информация о загрузке серверов не требуется, заключается в том, чтобы распределить запрос на случайный сервер.
В таком случае максимальная нагрузка на $n$ серверов с высокой вероятностью составит $\Theta(\frac{\log n }{\log \log n})$~\cite{pwr2choices}.

Если имеется $K$ запросов и $M$ узлов, при этом $2 <= N <= M$, то алгоритм состоит из следующих шагов:

\begin{enumerate}
	\item сформировать массив $nodes$, содержащий узлы;
	\item для каждого запроса из $K$:
	\begin{itemize}
		\item сформировать массив $randoms$, содержащий $N$ узлов, выбранных случайным образом из массива $nodes$;
		\item установить переменную $target$ на первый доступный узел --- $randoms[0]$;
		\item создать переменную $i = 1$;
		\item пока $i < M$:
		\begin{itemize}
			\item если нагрузка узла $randoms[i]$ меньше нагрузки узла $target$, то установить $target$ на узел $randoms[i]$;
			\item увеличить значение $i$;
		\end{itemize}
		\item отправить запрос на узел $target$.
	\end{itemize}
\end{enumerate}

Особенности алгоритма 2 (N) случайных выборов:
\begin{itemize}
    \item алгоритм анализирует текущую загрузку 2 (N) случайно выбранных узлов перед распределением запросов;
    \item алгоритм непрогнозируемый;
    \item алгоритм отказоустойчивый; 
    \item необходимо постоянно собирать информацию о некоторых узлах в реальном времени.
\end{itemize}

\subsection{Алгоритм на основе ресурсов}

Алгоритм на основе ресурсов --- алгоритм, при котором трафик распределяется балансировщиком нагрузки, в зависимости от текущей нагрузки на сервер~\cite{aws}.

Специализированное программное обеспечение, называемое агентом, запускается на каждом сервере и рассчитывает использование ресурсов сервера, таких как его вычислительная мощность и память. 
Затем агент проверяется балансировщиком нагрузки на наличие достаточного количества свободных ресурсов перед распределением трафика на данный сервер~\cite{aws}.

Если имеется $N$ запросов и $M$ узлов, то алгоритм состоит из следующих шагов:
\begin{enumerate}
	\item сформировать массив $nodes$, содержащий узлы;
	\item для каждого запроса из $N$:
	\begin{itemize}
		\item сформировать массив $resources$, содержащий информацию об использовании ресурсов, соответствующим узлом;
		\item установить переменную $target$ на первый доступный узел --- $resources[0]$;
		\item создать переменную $i = 0$;
		\item пока $i < M$:
		\begin{itemize}
			\item если узел $resources[i]$ обладает достаточным количеством свободных ресурсов для выполнения запроса, то установить $target$ на узел $resources[i]$ и  прекратить выполнение цикла;
			\item увеличить значение $i$;
		\end{itemize}
		\item отправить запрос на узел $target$.
	\end{itemize}
\end{enumerate}

Особенности алгоритма на основе ресурсов:
\begin{itemize}
	\item алгоритм гарантирует, что все запросы будут направляться на узлы, располагающие достаточным количеством свободных ресурсов для их обработки;
    \item алгоритм непрогнозируемый;
    \item алгоритм отказоустойчивый;
    \item необходимо постоянно собирать информацию о всех узлах в реальном времени;
    \item на каждом узле работает специализированное программное обеспечение, называемое агентом, которое рассчитывает текущее использование ресурсов.
\end{itemize}
