

\chapter{Аналитический раздел}

С ростом числа запросов к системе, встает вопрос о ее масштабировании. Масштабирование --- это процесс роста системы со временем, для эффективной обработки все большего и большего количества запросов в единицу времени~\cite{scaling}. Выделяют два вида масштабирования: горизонтальное и вертикальное~\mbox{\cite{comp, part_algos, com_analysis}}. Вертикальное масштабирование происходит за счет увеличения мощности вычислительного узла. Однако, использования только такого подхода часто не хватает, поскольку постоянно увеличивая мощность, однажды будет достигнут <<потолок>> производительности и дальнейшие аппаратные улучшения будут недоступны. В таком случае для дальнейшего роста производительности применяют горизонтальное масштабирование, которое заключается в добавлении новых вычислительных узлов, выполняющих одинаковые функции. Для расширения возможностей горизонтального масштабирования используются балансировщики нагрузки~\cite{part_algos, comp}.

Балансировщик нагрузки --- это программа, принимающая весь
входящий трафик запросов и распределяющая его между несколькими
вычислительными системами с целью оптимизации использования
ресурсов, сокращения времени обслуживания запросов, а также
обеспечения отказоустойчивости \cite{comp}.


\section{Постановка задачи}

В вычислительных сетях, использование распределения нагрузки для оптимизации использования ресурсов, называют балансировкой нагрузки \cite{gaud}.

Постановка задачи балансировки нагрузки выглядит следующим образом: имеется множество, состоящее из $n$ запросов, которое должно быть обслужено $M$ узлами. 
Каждый узел может обслуживать не более одного запроса в каждый момент времени. Каждый запрос обслуживается не более, чем одним узлом в каждый момент времени, а процесс обслуживания запроса не может быть прерван. 

Под расписанием понимается функция, которая каждому узлу $l$ и моменту времени $t$ сопоставляет запрос, обслуживаемый узлом $l$ в момент времени $t$, либо указывает, что узел $l$ в момент $t$ простаивает. Каждому запросу $i$ сопоставлена неубывающая функция штрафа $\phi_i(t)$. Тогда решением задачи балансировки нагрузки является составление расписания $s$, которое минимизирует выражение~\eqref{eq:main_task}~\cite{gaud}.

\begin{equation}
	\label{eq:main_task}	
	F_{max} =   \max_{i \in n} \{\phi_i(t_i(s))\}, 
\end{equation}

где $t_i(s)$ --- момент завершения обслуживания запроса $i$ при расписании~$s$.

\section{Алгоритмы решения задачи балансировки}

Балансировщик нагрузки работает по одному из алгоритмов, решающих задачу балансировки. На вход этому алгоритму подается некоторое число запросов, приходящих в систему и набор вычислительных узлов, которыми располагает система. Задача алгоритма сводится к минимизации времени обработки запросов, за счет распределения запросов по вычислительным узлам.

Для анализа алгоритмов балансировки могут быть выделены следующие параметры~\cite{com_analysis}:
\begin{itemize}
	\item точность прогнозирования --- степень соответствия расчетных результатов работы алгоритма их фактическому значению;  
	\item отказоустойчивость --- показывает устойчивость
	алгоритма к возникновению разнообразных ошибок;
	\item время обработки нового запроса --- время от поступления нового запроса до его перенаправления к цели.
\end{itemize}

Методы балансировки условно разделяют на статические и динамические~\cite{drr, com_analysis, rate_comp}. 

При динамической балансировке нагрузки, распределение запросов происходит на основе собранной информации об узлах. 

В статических алгоритмах, запрос распределяется в узел при появлении в балансировщике, а состояние узлов не оказывает влияния на это распределение~\cite{rate_comp, com_analysis}.


\section{Статическая балансировка}

Статическая балансировка --- это метод распределения нагрузки на узлы, основанный на заранее определенных параметрах.

К самым распространенным статическим алгоритмам относят: Round Robin и его модификацию Weighted Round Robin \cite{drr, comp, part_algos, com_analysis}.

\subsection{Round Robin}

Round Robin --- это алгоритм балансировки нагрузки, который направляет каждый следующий запрос на новый вычислительный узел по заранее определенному порядку \cite{comp}.

Пусть имеется $N$ запросов и $M$ узлов. Алгоритм состоит из следующих шагов.

\begin{enumerate}
	\item Сформировать массив, содержащий узлы.
	\item Создать переменную $i = 0$.
	\item Для каждого запроса из $N$:
	\begin{itemize}
		\item отправить текущий запрос на $i$-й узел в массиве;
		\item увеличить значение $i$;
		\item если $i >= M$, то $i = 0$.
	\end{itemize}	
\end{enumerate}

Особенности алгоритма Round Robin:
\begin{itemize}
	\item высокая степень точности прогнозирования;
	\item невозможно отследить вышел ли из строя узел, в результате, возможно, что на неработающий узел будут посылаться запросы, т.~е. низкая отказоустойчивость;
	\item никакие затратные по времени операции не производятся и попавший в балансировщик запрос практически сразу направляется в узел;
	\item различия в технических характеристиках узлов не учитываются, что может привести к неравномерному распределению нагрузки.
\end{itemize}


\textbf{Weighted Round Robin}


Алгоритм Weighted Round Robin представляет собой модификацию алгоритма Round Robin, в которой каждому узлу вручную назначается некоторый параметр, называемый весом, с помощью которого можно варьировать количество запросов, отправляемых на конкретный узел~\cite{part_algos}. Если помимо множества запросов и узлов, задан массив весов $weights$, длины $M$. Тогда алгоритм состоит из следующих шагов.
\begin{enumerate}
	\item Сформировать массив $nodes$ содержащий узлы, при этом повторить каждый $j$-й узел $weights[j]$ раз.
	\item Сохранить длину массива $nodes$ в переменную $L$.
	\item Создать переменную $i = 0$.
	\item Для каждого запроса из $N$:
	\begin{itemize}
		\item распределить текущий запрос на $i$-й узел в массиве;
		\item увеличить значение $i$;
		\item если $i >= L$, то $i = 0$.
	\end{itemize}	
\end{enumerate}


Особенности алгоритма Weighted Round Robin:
\begin{itemize}
	\item высокая степень точности прогнозирования;
	\item низкая отказоустойчивость, поскольку невозможно отследить вышел ли из строя некоторый узел, при этом, если вышел из строя узел с самым высоким весом, то на него все еще будет посылаться большее число запросов;
	\item благодаря весам, возможно осуществить настройку алгоритма таким образом, чтобы он учитывал различия в технических характеристиках узлов.
\end{itemize}



\section{Динамическая балансировка}

Особенностью динамических алгоритмов балансировки является необходимость в постоянном обмене актуальной информацией о узлах.
Простой способ периодического децентрализованного обмена информацией о состоянии заключается в том, что каждый узел периодически отправляет свое текущее состояние всем другим узлам \cite{drr}.

К динамическим алгоритмам относятся следующие~\cite{drr, dll_warsh, mainsource}:
\begin{itemize}
	\item Dynamic Round Robin;
	\item Least Connections;
	\item Weighted Least Connections;
	\item Least Time.
\end{itemize}


\subsection{Dynamic Round Robin}

Алгоритм Dynamic Round Robin динамически изменяет расписание, т.~е. распределение запросов по узлам, в зависимости от текущих характеристик узлов \cite{drr}. Dynamic Round Robin может исключать недоступные узлы, перенаправляя задачи на доступные узлы, что позволяет избежать проблем при работе с неисправными узлами. 
В алгоритме Dynamic Round Robin на расписание могут влиять следующие характеристики \cite{dll_warsh, com_analysis, part_algos}: 
\begin{itemize}
	\item количество соединений;
	\item среднее значение загрузки системы за период в 1 минуту, строится на основе процессов, т.~е. программ в стадии выполнения, стоящих в очереди ожидания ресурсов, выражается как отношение количества ожидающих процессов к общему количеству ядер;
	\item загрузка процессора узла в текущий момент времени, выраженная в процентах;
	\item использование памяти узла, выраженное в процентах относительно общего количества;
	\item географическое расстояние между узлами.
\end{itemize}
Алгоритм Dynamic Round Robin, выбирающий узлы по их текущей нагрузке, состоит из следующих шагов для каждого входящего запроса  \cite{com_analysis}.
\begin{enumerate}
	\item Установить переменную \textit{target} на первый доступный узел.
	\item Цикл по всем доступным узлам, кроме первого:
	 \begin{itemize}
	 	\item если нагрузка на текущий рассматриваемый узел меньше нагрузки узла \textit{target}, то установить \textit{target} на текущий узел.
	 \end{itemize}
	\item Отправить запрос на узел \textit{target}.
\end{enumerate}

Особенности алгоритма Dynamic Round Robin:
\begin{itemize}
	\item низкая точность прогнозирования, поскольку распределение запросов сильно зависит от внешних факторов;
	\item высокая отказоустойчивость, поскольку в алгоритме учитывается ситуация отказа узлов.
\end{itemize}


\subsection{Least Connections}

Алгоритм Least Connections распределяет нагрузку между узлами, в зависимости от количества активных соединений, обслуживаемых каждым узлом.
Узел с наименьшим числом соединений будет обрабатывать следующий запрос, а узлы с большим числом соединений будут перераспределять свою нагрузку на узлы с меньшей загрузкой~\cite{leastconnection}.

Если имеется $N$ запросов, $M$ узлов и для каждого узла есть количество активных соединений $conns$. 
Тогда алгоритм состоит из следующих шагов:
\begin{enumerate}
	\item сформировать массив, содержащий узлы;
	\item установить указатель $target$ на первый узел;
	\item пройтись циклом по всем узлам массива, кроме первого:
	\begin{itemize}
		\item если $conns$ текущего узла меньше $conns$ узла $target$, то установить $target$ на текущий узел; 
	\end{itemize}
	\item отправить запрос на узел $target$.
\end{enumerate}

Особенности алгоритма Least Connections:
\begin{itemize}
	\item низкая степень прогнозирования; 
	\item низкая стабильность;
	\item высокая отказоустойчивость, поскольку постоянно собирается информация об узлах, и, в случае отказа, система перераспределит ресурсы;
	\item высокая потребность в ресурсах, поскольку необходимо постоянно собирать информацию о узлах в реальном времени;
	\item высокое время обработки нового запроса, поскольку балансировщику нагрузки необходимо время, чтобы правильно перенаправить задачу.
\end{itemize}

\textbf{Weighted Least Connections}

Данный алгоритм комбинирует принципы алгоритмов Least Connections и Weighted Round Robin~\cite{part_algos}.
Он учитывает как веса узлов, так и количество активных соединений. 
Новое сетевое подключение предоставляется узлу, который имеет минимальное отношение количества текущих активных подключений к его весу \cite{mainsource}.

Если имеется $N$ запросов, $M$ узлов и для каждого узла есть количество соединений $conns$ и вес $weight$.
Тогда алгоритм состоит из следующих шагов:
\begin{enumerate}
	\item сформировать массив, содержащий узлы;
	\item установить указатель $target$ на первый узел;
	\item пройтись циклом по всем узлам массива, кроме первого:
	\begin{itemize}
	\item если отношение $conns$ и $weight$ текущего узла меньше отношения $conns$ и $weight$ узла $target$, то установить $target$ на текущий узел; 
	\end{itemize}
	\item отправить запрос на узел $target$.
\end{enumerate}

Особенности алгоритма Weighted Least Connections:
\begin{enumerate}
	\item низкая степень прогнозирования; 
	\item низкая стабильность;
	\item высокая отказоустойчивость;
	\item высокая потребность в ресурсах;
	\item высокое время обработки нового запроса;
	\item благодаря весам, возможно осуществить настройку алгоритма таким образом, чтобы он учитывал различия в технических характеристиках узлов.
\end{enumerate}