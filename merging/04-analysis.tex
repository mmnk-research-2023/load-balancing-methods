

\chapter{Аналитический раздел}

С ростом числа запросов к системе, встает вопрос о ее масштабировании. 
Масштабирование --- это процесс роста системы со временем, для эффективной обработки все большего и большего количества запросов в единицу времени~\cite{scaling}. 
Выделяют два вида масштабирования: горизонтальное и вертикальное~\mbox{\cite{comp, part_algos, com_analysis}}.
Вертикальное масштабирование происходит за счет увеличения мощности вычислительного узла.  
Горизонтальное масштабирование, заключается в добавлении новых вычислительных узлов, выполняющих одинаковые функции.
Для расширения возможностей горизонтального масштабирования используются балансировщики нагрузки~\cite{part_algos, comp}.

Балансировщик нагрузки --- это программа, принимающая весь
входящий трафик запросов и распределяющая его между несколькими
вычислительными узлами с целью оптимизации использования
ресурсов, сокращения времени обслуживания запросов, а также
обеспечения отказоустойчивости~\cite{comp}.


\section{Постановка задачи}

Постановка задачи балансировки нагрузки формулируется следующим образом: имеется множество, состоящее из $n$ запросов, которое должно быть обслужено $M$ узлами. 
Каждый узел может обслуживать не более одного запроса в каждый момент времени.
Каждый запрос обслуживается не более, чем одним узлом в каждый момент времени, а процесс обслуживания запроса не может быть прерван. 

Под расписанием понимается функция, которая каждому узлу $l$ и моменту времени $t$ сопоставляет запрос, обслуживаемый узлом $l$ в момент времени $t$, либо указывает, что узел $l$ в момент $t$ простаивает.
Каждому запросу $i$ сопоставлена неубывающая функция штрафа $\phi_i(t)$.
Тогда решением задачи балансировки нагрузки является составление расписания $s$, которое минимизирует выражение~\eqref{eq:main_task}~\cite{gaud}.

\begin{equation}
	\label{eq:main_task}	
	F_{max} =   \max_{i \in n} \{\phi_i(t_i(s))\}, 
\end{equation}

где $t_i(s)$ --- момент завершения обслуживания запроса $i$ при расписании~$s$.

\section{Алгоритмы решения задачи балансировки}

Балансировщик нагрузки работает по одному из алгоритмов, решающих задачу балансировки.
На вход этому алгоритму подаются набор запросов, приходящих в систему и набор вычислительных узлов, которыми система располагает.
Задача алгоритма сводится к минимизации времени обработки запросов за счет распределения запросов по вычислительным узлам.

Для анализа алгоритмов балансировки выделяют следующие критерии~\cite{com_analysis}:
\begin{itemize}
	\item точность прогнозирования --- степень соответствия расчетных результатов работы алгоритма их фактическому значению;  
	\item отказоустойчивость --- показывает устойчивость
	алгоритма к возникновению разнообразных ошибок;
	\item время обработки нового запроса --- время от поступления нового запроса до его перенаправления к цели.
\end{itemize}

Методы балансировки условно разделяют на статические и динамические~\cite{drr, com_analysis, rate_comp}. 

\section{Статическая балансировка}

Статическая балансировка --- это метод распределения нагрузки на узлы, основанный на заранее определенных параметрах~\cite{com_analysis, intuit}.

К статическим алгоритмам балансировки относят~\mbox{\cite{nginx, aws, haproxy, part_algos, com_analysis}}:
\begin{itemize}
	\item алгоритмы циклического перебора (англ. Round Robin);
	\item алгоритмы на основе хеширования.
\end{itemize}


\subsection{Алгоритмы циклического перебора}

В алгоритмах циклического перебора каждый следующий запрос отправляется на новый вычислительный узел по заранее определенному порядку~\cite{comp}.

Если имеется $N$ запросов и $M$ узлов. Тогда алгоритм состоит из следующих шагов:

\begin{enumerate}
	\item сформировать массив, содержащий узлы;
	\item создать переменную $i = 0$;
	\item для каждого запроса из $N$:
	\begin{itemize}
		\item отправить текущий запрос на $i$-й узел в массиве;
		\item увеличить значение $i$;
		\item если $i >= M$, то $i = 0$.
	\end{itemize}	
\end{enumerate}

Особенности алгоритма равномерного распределения:
\begin{itemize}
	\item высокая степень точности прогнозирования;
	\item невозможно отследить вышел ли из строя узел, в результате, возможно, что на неработающий узел будут посылаться запросы, т.~е. низкая отказоустойчивость;
	\item никакие затратные по времени операции не производятся в балансировщике;
	\item различия в технических характеристиках узлов не учитываются, что может привести к неравномерному распределению нагрузки.
\end{itemize}


\subsection*{Взвешенный алгоритм циклического перебора}

Алгоритм взвешенного циклического перебора (англ. Weighted Round Robin) представляет собой модификацию алгоритма равномерного распределения, в которой каждому узлу вручную назначается некоторый параметр, называемый весом, с помощью которого можно варьировать количество запросов, отправляемых на конкретный узел~\cite{part_algos}.
Если помимо множества запросов и узлов, задан массив весов $weights$, длины $M$, то алгоритм состоит из следующих шагов:
\begin{enumerate}
	\item сформировать массив $nodes$ содержащий узлы, при этом повторить каждый $j$-й узел $weights[j]$ раз;
	\item сохранить длину массива $nodes$ в переменную $L$;
	\item создать переменную $i = 0$;
	\item для каждого запроса из $N$:
	\begin{itemize}
		\item распределить текущий запрос на $i$-й узел в массиве;
		\item увеличить значение $i$;
		\item если $i >= L$, то $i = 0$.
	\end{itemize}	
\end{enumerate}


Особенности алгоритма взвешенного циклического перебора:
\begin{itemize}
	\item высокая степень точности прогнозирования;
	\item низкая отказоустойчивость, поскольку невозможно отследить вышел ли из строя некоторый узел, при этом, если вышел из строя узел с самым высоким весом, то на него все еще будет посылаться большее число запросов;
	\item благодаря весам, возможно осуществить настройку алгоритма таким образом, чтобы он учитывал различия в технических характеристиках узлов.
\end{itemize}

\subsection{Алгоритмы на основе хеширования}

Алгоритмы балансировки нагрузки на основе хеширования работают по общему принципу:
\begin{enumerate}
	\item из пришедшего запроса выбрать информацию (например, IP-адрес или URL-адрес), которая считается ключом хеш-функции в рамках данного алгоритма;
	\item на основе ключа вычислить значение хеш-функции, которое соответствует идентификатору узла, на который следует перенаправить запрос для его обработки;
	\item перенаправить запрос на узел, чей идентификатор был вычислен ранее.
\end{enumerate}

\subsection*{Хеширование на основе IP-адреса}

Алгоритм балансировки нагрузки <<Хеширование на основе IP-адреса>> работает по общему принципу методов балансировки нагрузки на основе хеширования.
Ключом хеш-функции в данном алгоритме считается IP-адрес источника запроса~\cite{nginx, aws, kemp}.
Запросы, имеющие один и тот же IP-адрес, будут обслужены одним и тем же узлом.
Если имеются запросы $r_1$, $r_2$, узлы $l_1$, $l_2$, моменты времени $t_1$, $t_2$ и функция расписания $s$, то, в соответствии с данным алгоритмом, будет выполнено следующее:
\begin{equation}
	(\forall t_1, t_2) \left(\begin{cases}
		s(l_1, t_1) = r_1, \\
		s(l_2, t_2) = r_2, \\
		r_1.ip\_address = r_2.ip\_address.
	\end{cases} \Rightarrow l_1 = l_2 \right).
\end{equation}

Особенности алгоритма <<Хеширование на основе IP-адреса>>:
\begin{itemize}
	\item алгоритм гарантирует, что все запросы от одного и того же пользователя направляются на один и тот же сервер;
	\item алгоритм обладает высокой степенью точности прогнозирования;
	\item добавление новых серверов потребует лишь изменения хеш-функции для корректной работы алгоритма;
	\item неравномерная нагрузка на узел, если запросы начинают приходить из сети, использующей NAT, с большим количеством пользователей.
\end{itemize}

\subsection*{Хеширование на основе URL-адреса}

Алгоритм балансировки нагрузки <<Хеширование на основе URL-адреса>> работает по общему принципу методов балансировки нагрузки на основе хеширования.
Ключом хеш-функции в данном алгоритме считается URL-адрес, к которому обращается источник запроса~\cite{nginx, kemp, haproxy}.
Запросы к одному и тому же URL-адресу, будут обслужены одним и тем же узлом.
То есть, если имеются запросы $r_1$, $r_2$, узлы $l_1$, $l_2$, моменты времени $t_1$, $t_2$ и функция расписания $s$, то, в соответствии с данным алгоритмом, будет выполнено следующее:
\begin{equation}
	(\forall t_1, t_2) \left(\begin{cases}
		s(l_1, t_1) = r_1, \\
		s(l_2, t_2) = r_2, \\
		r_1.url\_address = r_2.url\_address.
	\end{cases} \Rightarrow l_1 = l_2 \right)
\end{equation}

Особенности алгоритма <<Хеширование на основе URL-адреса>>:
\begin{itemize}
	\item алгоритм гарантирует, что все запросы к одному и тому же URL направляются на тот же сервер;
	\item алгоритм обладает высокой степенью точности прогнозирования;
	\item изменение структуры URL может потребовать перенастройки балансировщика;
	\item популярные URL могут создавать неравномерную нагрузку на узлы.
\end{itemize}

\section{Динамическая балансировка}

Динамическая балансировка --- это метод распределения нагрузки на узлы, который предусматривает перераспределение вычислительной нагрузки на узлы во время работы~\cite{intuit}.
 

Особенностью динамических алгоритмов балансировки является необходимость в постоянном обмене актуальной информацией о узлах.
Простой способ периодического децентрализованного обмена информацией о состоянии заключается в том, что каждый узел периодически отправляет свое текущее состояние всем другим узлам \cite{drr}.

К динамическим алгоритмам относят следующие~\cite{drr, dll_warsh, mainsource}:
\begin{itemize}
	\item алгоритм динамического циклического перебора (англ. Dynamic Round Robin);
	\item алгоритмы наименьших соединений (англ. Least Connections);
	\item алгоритм наименьшего времени ответа (англ. Least Response Time);
	\item алгоритм фиксированных весов;
	\item алгоритм 2 (N) случайных выборов (англ. Random 2 (N) choices);
	\item алгоритм на основе ресурсов (англ. Resource based).
\end{itemize}


\subsection{Алгоритм динамического циклического перебора}

Динамический алгоритм циклического перебора изменяет расписание, т.~е. распределение запросов по узлам, в зависимости от текущих характеристик узлов~\cite{drr}.
Алгоритм может исключать недоступные узлы, перенаправляя задачи на доступные узлы, что позволяет избежать проблем при работе с неисправными узлами. 
В алгоритме динамического циклического перебора на расписание могут влиять следующие характеристики~\cite{dll_warsh, com_analysis, part_algos}: 
\begin{itemize}
	\item количество соединений;
	\item среднее значение загрузки системы за период в 1 минуту, строится на основе процессов, т.~е. программ в стадии выполнения, стоящих в очереди ожидания ресурсов, выражается как отношение количества ожидающих процессов к общему количеству ядер;
	\item загрузка процессора узла в текущий момент времени, выраженная в процентах;
	\item использование памяти узла, выраженное в процентах относительно общего количества;
	\item географическое расстояние между узлами.
\end{itemize}
Алгоритм динамического циклического перебора, выбирающий узлы по их текущей нагрузке, состоит из следующих шагов для каждого входящего запроса~\cite{com_analysis}:
\begin{enumerate}
	\item установить переменную \textit{target} на первый доступный узел;
	\item цикл по всем доступным узлам, кроме первого:
	 \begin{itemize}
	 	\item если нагрузка на текущий рассматриваемый узел меньше нагрузки узла \textit{target}, то установить \textit{target} на текущий узел;
	 \end{itemize}
	\item отправить запрос на узел \textit{target}.
\end{enumerate}

Особенности алгоритма динамического циклического перебора:
\begin{itemize}
	\item низкая точность прогнозирования, поскольку распределение запросов сильно зависит от внешних факторов;
	\item высокая отказоустойчивость, поскольку в алгоритме учитывается ситуация отказа узлов.
\end{itemize}


\subsection{Алгоритмы наименьших соединений}

Алгоритм наименьших соединений распределяет нагрузку между узлами, в зависимости от количества активных соединений, обслуживаемых каждым узлом.
Узел с наименьшим числом соединений будет обрабатывать следующий запрос, а узлы с большим числом соединений будут перераспределять свою нагрузку на узлы с меньшей загрузкой~\cite{leastconnection}.

Если имеется $N$ запросов, $M$ узлов и для каждого узла есть количество активных соединений $conns$. 
Тогда алгоритм состоит из следующих шагов:
\begin{enumerate}
	\item сформировать массив, содержащий узлы;
	\item установить указатель $target$ на первый узел;
	\item пройтись циклом по всем узлам массива, кроме первого:
	\begin{itemize}
		\item если $conns$ текущего узла меньше $conns$ узла $target$, то установить $target$ на текущий узел; 
	\end{itemize}
	\item отправить запрос на узел $target$.
\end{enumerate}

Особенности алгоритма наименьших соединений:
\begin{itemize}
	\item низкая степень прогнозирования; 
	\item низкая стабильность;
	\item высокая отказоустойчивость, поскольку постоянно собирается информация об узлах, и, в случае отказа, система перераспределит ресурсы;
	\item высокая потребность в ресурсах, поскольку необходимо постоянно собирать информацию о узлах в реальном времени;
	\item высокое время обработки нового запроса, поскольку балансировщику нагрузки необходимо время, чтобы правильно перенаправить задачу.
\end{itemize}

\subsection*{Алгоритм взвешенных наименьших соединений}

Данный алгоритм комбинирует принципы алгоритма наименьших соединений и алгоритма взвешенного циклического перебора~\cite{part_algos}.
Он учитывает как веса узлов, так и количество активных соединений. 
Новое сетевое подключение предоставляется узлу, который имеет минимальное отношение количества текущих активных подключений к его весу~\cite{mainsource}.

Если имеется $N$ запросов, $M$ узлов и для каждого узла есть количество соединений $conns$ и вес $weight$.
Тогда алгоритм состоит из следующих шагов:
\begin{enumerate}
	\item сформировать массив, содержащий узлы;
	\item установить указатель $target$ на первый узел;
	\item пройтись циклом по всем узлам массива, кроме первого:
	\begin{itemize}
	\item если отношение $conns$ и $weight$ текущего узла меньше отношения $conns$ и $weight$ узла $target$, то установить $target$ на текущий узел; 
	\end{itemize}
	\item отправить запрос на узел $target$.
\end{enumerate}

Особенности алгоритма взвешенных наименьших соединений:
\begin{itemize}
	\item низкая степень прогнозирования; 
	\item низкая стабильность;
	\item высокая отказоустойчивость;
	\item высокая потребность в ресурсах;
	\item высокое время обработки нового запроса;
	\item благодаря весам, возможно осуществить настройку алгоритма таким образом, чтобы он учитывал различия в технических характеристиках узлов.
\end{itemize}


\subsection{Алгоритм наименьшего времени ответа}

Данный алгоритм имеет схожесть с алгоритмом наименьших соединений, только при распределении нагрузки он руководствуется наименьшим временем ответа узла.
При выборе учитывается производительность узлов и балансировщик стремится направить запрос к наиболее подходящему узлу~\cite{aws}.

Если имеется $N$ запросов, $M$ узлов и для каждого узла есть время ответа на предыдущий запрос $time$.
Тогда алгоритм состоит из следующих шагов:

\begin{enumerate}
	\item сформировать массив, содержащий узлы;
	\item установить указатель $target$ на первый узел;
	\item пройтись циклом по всем узлам массива, кроме первого:
	\begin{itemize}
		\item если $time$ текущего узла меньше $time$ узла $target$, то установить $target$ на текущий узел; 
	\end{itemize}
	\item отправить запрос на узел $target$.
\end{enumerate}

Особенности алгоритма наименьшего времени ответа:
\begin{itemize}
	\item низкая степень прогнозирования; 
	\item низкая стабильность;
	\item высокая отказоустойчивость;
	\item высокая потребность в ресурсах;
	\item высокое время обработки нового запроса;
	\item если время ответа каждого узла одинаково, то алгоритм следует выбору по правилам алгоритма циклического перебора.
\end{itemize}

\subsection{Алгоритм фиксированных весов}

В алгоритме фиксированных весов, администратор назначает каждому узлу вес, после чего все запросы будут приходить на узел с максимальным весом~\cite{kemp}.
Если узел перестает справляться с нагрузкой, запросы начинают перенаправляться на узел, с весом меньше.

Если имеется $M$ узлов, записанных в массив $nodes$ и $weights$ --- массив весов, назначенных администратором.
Тогда алгоритм для каждого приходящего запроса состоит из следующих шагов:
\begin{enumerate}
	\item записать в $w$ максимальное значение $weights$;
	\item $request\_sent\_flag = 0$;
	\item пока $request\_sent\_flag = 0$ и $w > 0$:
	\begin{itemize}
		\item записать в $node$ узел, вес которого равен $w$;
		\item если узел $node$ может принять запрос то, перенаправить запрос узлу $node$, установить значение $request\_sent\_flag = 1$;
		\item иначе, $w = w - 1$.
	\end{itemize}
\end{enumerate}

Таким образом, если имеется запрос $r$, узел $l$, момент времени $t$, функция расписания $s$, и выполняется равенство $s(l, t) = r$ то, $l$ --- узел с наибольшим весом, доступный в момент времени $t$.

Особенности алгоритма фиксированных весов:
\begin{itemize}
	\item алгоритм гарантирует, что все запросы будут направляться на доступный в текущий момент времени узел с максимальным весом;
	\item алгоритм обладает низкой степенью прогнозируемости;
	\item веса узлов назначаются вручную;
	\item вес узла не меняется в процессе работы.
\end{itemize}

\subsection{Алгоритм 2 (N) случайных выборов}

Алгоритм 2 (N) случайных выборов --- алгоритм, при котором определяется нагрузка $N \ge 2$ серверов, выбранных случайным образом, и запрос отправляется на наименее загруженный из них. 
В случае $N=2$ максимальная нагрузка на $n$ серверов с большой вероятностью составит $\Theta(\log  \log n)$~\cite{pwr2choices}.

Данный метод может быть использован, когда запрос требуется отправить на наименее загруженный сервер. 
Однако, полная информация о загрузке всех серверов может оказаться дорогостоящей для получения. 
Например, для получения загрузки на сервер может потребоваться отправка сообщения и ожидание ответа, 
обработка прерывания сервером~\cite{pwr2choices}.

Альтернативный подход при котором информация о загрузке серверов не требуется, заключается в том, чтобы распределить запрос на случайный сервер.
В таком случае максимальная нагрузка на $n$ серверов с высокой вероятностью составит $\Theta(\log n / \log \log n)$. \cite{pwr2choices}

Если имеется $K$ запросов и $M$ узлов, при этом $2 <= N <= M$. Тогда алгоритм состоит из следующих шагов:

\begin{enumerate}
	\item сформировать массив $nodes$, содержащий узлы;
	\item для каждого запроса из $K$:
	\begin{itemize}
		\item сформировать массив $randoms$, содержащий $N$ узлов, выбранных случайным образом из массива $nodes$;
		\item установить переменную $target$ на первый доступный узел --- $randoms[0]$;
		\item создать переменную $i = 1$;
		\item пока $i < M$:
		\begin{itemize}
			\item если нагрузка узла $randoms[i]$ меньше нагрузки узла $target$, то установить $target$ на узел $randoms[i]$;
			\item увеличить значение $i$;
		\end{itemize}
		\item отправить запрос на узел $target$.
	\end{itemize}
\end{enumerate}

\subsection{Алгоритм на основе ресурсов}

Алгоритм на основе ресурсов --- алгоритм, при котором трафик распределяется балансировщиком нагрузки, в зависимости от текущей нагрузки на сервер~\cite{aws}.

Специализированное программное обеспечение, называемое агентом, запускается на каждом сервере и рассчитывает использование ресурсов сервера, таких как его вычислительная мощность и память. 
Затем агент проверяется балансировщиком нагрузки на наличие достаточного количества свободных ресурсов перед распределением трафика на данный сервер~\cite{aws}.

Если имеется $N$ запросов и $M$ узлов. Тогда алгоритм состоит из следующих шагов:
\begin{enumerate}
	\item сформировать массив $nodes$, содержащий узлы;
	\item для каждого запроса из $N$:
	\begin{itemize}
		\item сформировать массив $resources$, содержащий информацию об использовании ресурсов, соответствующим узлом;
		\item установить переменную $target$ на первый доступный узел --- $resources[0]$;
		\item создать переменную $i = 0$;
		\item пока $i < M$:
		\begin{itemize}
			\item узел $resources[i]$ обладает достаточным количеством свободных ресурсов для выполнения запроса:
			\begin{itemize}
				\item установить $target$ на узел $resources[i]$; 
				\item прекратить выполнение цикла;
			\end{itemize}
			\item увеличить значение $i$;
		\end{itemize}
		\item отправить запрос на узел $target$.
	\end{itemize}
\end{enumerate}